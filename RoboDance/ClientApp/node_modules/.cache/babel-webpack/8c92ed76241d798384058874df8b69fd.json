{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n/**\n* @license Angular v9.1.0-next.4+61.sha-e552591.with-local-changes\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  (function (global) {\n    var OriginalDate = global.Date;\n\n    var FakeDate =\n    /** @class */\n    function () {\n      function FakeDate() {\n        if (arguments.length === 0) {\n          var d = new OriginalDate();\n          d.setTime(FakeDate.now());\n          return d;\n        } else {\n          var args = Array.prototype.slice.call(arguments);\n          return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n        }\n      }\n\n      FakeDate.now = function () {\n        var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncTestZoneSpec) {\n          return fakeAsyncTestZoneSpec.getCurrentRealTime() + fakeAsyncTestZoneSpec.getCurrentTime();\n        }\n\n        return OriginalDate.now.apply(this, arguments);\n      };\n\n      return FakeDate;\n    }();\n\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n\n    var Scheduler =\n    /** @class */\n    function () {\n      function Scheduler() {\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = []; // Current simulated time in millis.\n\n        this._currentTime = 0; // Current real time in millis.\n\n        this._currentRealTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n\n      Scheduler.prototype.getCurrentTime = function () {\n        return this._currentTime;\n      };\n\n      Scheduler.prototype.getCurrentRealTime = function () {\n        return this._currentRealTime;\n      };\n\n      Scheduler.prototype.setCurrentRealTime = function (realTime) {\n        this._currentRealTime = realTime;\n      };\n\n      Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n        options = Object.assign({\n          args: [],\n          isPeriodic: false,\n          isRequestAnimationFrame: false,\n          id: -1,\n          isRequeuePeriodic: false\n        }, options);\n        var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        var endTime = this._currentTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n        var newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n\n        var i = 0;\n\n        for (; i < this._schedulerQueue.length; i++) {\n          var currentEntry = this._schedulerQueue[i];\n\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n\n        this._schedulerQueue.splice(i, 0, newEntry);\n\n        return currentId;\n      };\n\n      Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n        for (var i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n\n            break;\n          }\n        }\n      };\n\n      Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        var finalTime = this._currentTime + millis;\n        var lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n\n        var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          var current = schedulerQueue[0];\n\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            var current_1 = schedulerQueue.shift();\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              var idx = this._schedulerQueue.indexOf(current_1);\n\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n\n            lastCurrentTime = this._currentTime;\n            this._currentTime = current_1.endTime;\n\n            if (doTick) {\n              doTick(this._currentTime - lastCurrentTime);\n            }\n\n            var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTime] : current_1.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            } // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                var i = 0;\n\n                for (; i < schedulerQueue.length; i++) {\n                  var currentEntry = schedulerQueue[i];\n\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n\n        lastCurrentTime = this._currentTime;\n        this._currentTime = finalTime;\n\n        if (doTick) {\n          doTick(this._currentTime - lastCurrentTime);\n        }\n      };\n\n      Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n        if (limit === void 0) {\n          limit = 20;\n        }\n\n        if (flushPeriodic === void 0) {\n          flushPeriodic = false;\n        }\n\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      };\n\n      Scheduler.prototype.flushPeriodic = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTime - startTime;\n      };\n\n      Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n        var startTime = this._currentTime;\n        var lastCurrentTime = 0;\n        var count = 0;\n\n        while (this._schedulerQueue.length > 0) {\n          count++;\n\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          } // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n          if (this._schedulerQueue.filter(function (task) {\n            return !task.isPeriodic && !task.isRequestAnimationFrame;\n          }).length === 0) {\n            break;\n          }\n\n          var current = this._schedulerQueue.shift();\n\n          lastCurrentTime = this._currentTime;\n          this._currentTime = current.endTime;\n\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTime - lastCurrentTime);\n          }\n\n          var retval = current.func.apply(global, current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n\n        return this._currentTime - startTime;\n      };\n\n      return Scheduler;\n    }(); // Next scheduler id.\n\n\n    Scheduler.nextId = 1;\n\n    var FakeAsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n        if (trackPendingRequestAnimationFrame === void 0) {\n          trackPendingRequestAnimationFrame = false;\n        }\n\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n\n      FakeAsyncTestZoneSpec.assertInZone = function () {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n        var _this = this;\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          fn.apply(global, args);\n\n          if (_this._lastError === null) {\n            // Success\n            if (completers.onSuccess != null) {\n              completers.onSuccess.apply(global);\n            } // Flush microtasks only on success.\n\n\n            _this.flushMicrotasks();\n          } else {\n            // Failure\n            if (completers.onError != null) {\n              completers.onError.apply(global);\n            }\n          } // Return true if there were no errors, false otherwise.\n\n\n          return _this._lastError === null;\n        };\n      };\n\n      FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n        var index = timers.indexOf(id);\n\n        if (index > -1) {\n          timers.splice(index, 1);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n        var _this = this;\n\n        return function () {\n          // Requeue the timer callback if it's not been canceled.\n          if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n            _this._scheduler.scheduleFunction(fn, interval, {\n              args: args,\n              isPeriodic: true,\n              id: id,\n              isRequeuePeriodic: true\n            });\n          }\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n        if (isTimer === void 0) {\n          isTimer = true;\n        }\n\n        var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n        var cb = this._fnAndFlush(fn, {\n          onSuccess: removeTimerFn,\n          onError: removeTimerFn\n        });\n\n        var id = this._scheduler.scheduleFunction(cb, delay, {\n          args: args,\n          isRequestAnimationFrame: !isTimer\n        });\n\n        if (isTimer) {\n          this.pendingTimers.push(id);\n        }\n\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n        var id = Scheduler.nextId;\n        var completers = {\n          onSuccess: null,\n          onError: this._dequeuePeriodicTimer(id)\n        };\n\n        var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n        this._scheduler.scheduleFunction(cb, interval, {\n          args: args,\n          isPeriodic: true\n        });\n\n        this.pendingPeriodicTimers.push(id);\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n        var error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getCurrentTime = function () {\n        return this._scheduler.getCurrentTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getCurrentRealTime = function () {\n        return this._scheduler.getCurrentRealTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.setCurrentRealTime = function (realTime) {\n        this._scheduler.setCurrentRealTime(realTime);\n      };\n\n      FakeAsyncTestZoneSpec.patchDate = function () {\n        if (!!global[Zone.__symbol__('disableDatePatching')]) {\n          // we don't want to patch global Date\n          // because in some case, global Date\n          // is already being patched, we need to provide\n          // an option to let user still use their\n          // own version of Date.\n          return;\n        }\n\n        if (global['Date'] === FakeDate) {\n          // already patched\n          return;\n        }\n\n        global['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n      };\n\n      FakeAsyncTestZoneSpec.resetDate = function () {\n        if (global['Date'] === FakeDate) {\n          global['Date'] = OriginalDate;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n        if (global.setTimeout !== timers.setTimeout) {\n          global.setTimeout = timers.setTimeout;\n          global.clearTimeout = timers.clearTimeout;\n        }\n\n        if (global.setInterval !== timers.setInterval) {\n          global.setInterval = timers.setInterval;\n          global.clearInterval = timers.clearInterval;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tick(millis, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n        var _this = this;\n\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        var flushErrors = function flushErrors() {\n          if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n            // If there is an error stop processing the microtask queue and rethrow the error.\n            _this._resetLastErrorAndThrow();\n          }\n        };\n\n        while (this._microtasks.length > 0) {\n          var microtask = this._microtasks.shift();\n\n          microtask.func.apply(microtask.target, microtask.args);\n        }\n\n        flushErrors();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n            var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n            // currently we know process.nextTick will have such additional\n            // arguments\n\n            var additionalArgs = void 0;\n\n            if (args) {\n              var callbackIndex = task.data.cbIdx;\n\n              if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n              }\n            }\n\n            this._microtasks.push({\n              func: task.invoke,\n              args: additionalArgs,\n              target: task.data && task.data.target\n            });\n\n            break;\n\n          case 'macroTask':\n            switch (task.source) {\n              case 'setTimeout':\n                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'setImmediate':\n                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                break;\n\n              case 'setInterval':\n                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'XMLHttpRequest.send':\n                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n              case 'requestAnimationFrame':\n              case 'webkitRequestAnimationFrame':\n              case 'mozRequestAnimationFrame':\n                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                // (60 frames per second)\n                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                break;\n\n              default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                var macroTaskOption = this.findMacroTaskOption(task);\n\n                if (macroTaskOption) {\n                  var args_1 = task.data && task.data['args'];\n                  var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                  var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n\n                  if (!!macroTaskOption.isPeriodic) {\n                    // periodic macroTask, use setInterval to simulate\n                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                    task.data.isPeriodic = true;\n                  } else {\n                    // not periodic, use setTimeout to simulate\n                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                  }\n\n                  break;\n                }\n\n                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n            }\n\n            break;\n\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n\n        return task;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        switch (task.source) {\n          case 'setTimeout':\n          case 'requestAnimationFrame':\n          case 'webkitRequestAnimationFrame':\n          case 'mozRequestAnimationFrame':\n            return this._clearTimeout(task.data['handleId']);\n\n          case 'setInterval':\n            return this._clearInterval(task.data['handleId']);\n\n          default:\n            // user can define which macroTask they want to support by passing\n            // macroTaskOptions\n            var macroTaskOption = this.findMacroTaskOption(task);\n\n            if (macroTaskOption) {\n              var handleId = task.data['handleId'];\n              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n            }\n\n            return delegate.cancelTask(target, task);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n          FakeAsyncTestZoneSpec.patchDate();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          if (!this.patchDateLocked) {\n            FakeAsyncTestZoneSpec.resetDate();\n          }\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n        if (!this.macroTaskOptions) {\n          return null;\n        }\n\n        for (var i = 0; i < this.macroTaskOptions.length; i++) {\n          var macroTaskOption = this.macroTaskOptions[i];\n\n          if (macroTaskOption.source === task.source) {\n            return macroTaskOption;\n          }\n        }\n\n        return null;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n      };\n\n      return FakeAsyncTestZoneSpec;\n    }(); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone && Zone['ProxyZoneSpec'];\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n\n      _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n      ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n\n\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n\n          var res = void 0;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n\n          try {\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" + \"periodic timer(s) still in the queue.\");\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n          }\n\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n    }\n\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n\n\n    function tick(millis, ignoreNestedTimeout) {\n      if (millis === void 0) {\n        millis = 0;\n      }\n\n      if (ignoreNestedTimeout === void 0) {\n        ignoreNestedTimeout = false;\n      }\n\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n\n\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n\n\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n\n      var pendingTimers = zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n\n\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  });\n});","map":{"version":3,"sources":["H:/Project/Parkside/RoboDance/RoboDance/ClientApp/node_modules/zone.js/dist/fake-async-test.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","factory","define","amd","global","OriginalDate","Date","FakeDate","d","setTime","now","args","prototype","slice","call","bind","apply","fakeAsyncTestZoneSpec","Zone","current","get","getCurrentRealTime","getCurrentTime","UTC","parse","timers","setTimeout","setInterval","clearTimeout","clearInterval","Scheduler","_schedulerQueue","_currentTime","_currentRealTime","_currentTickRequeuePeriodicEntries","setCurrentRealTime","realTime","scheduleFunction","cb","delay","options","Object","assign","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","push","currentEntry","splice","removeScheduledFunctionWithId","tick","millis","doTick","tickOptions","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","current_1","shift","idx","indexOf","retval","forEach","flush","limit","flushPeriodic","flushNonPeriodic","startTime","lastTask","count","Error","filter","task","FakeAsyncTestZoneSpec","namePrefix","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","Promise","__symbol__","pendingPeriodicTimers","pendingTimers","patchDateLocked","properties","name","assertInZone","_fnAndFlush","fn","completers","_this","_i","onSuccess","flushMicrotasks","onError","_removeTimer","index","_dequeueTimer","_requeuePeriodicTimer","interval","_dequeuePeriodicTimer","_setTimeout","isTimer","removeTimerFn","_clearTimeout","_setInterval","_clearInterval","_resetLastErrorAndThrow","error","patchDate","checkTimerPatch","resetDate","lockDatePatch","unlockDatePatch","flushErrors","microtask","target","elapsed","onScheduleTask","delegate","type","data","additionalArgs","callbackIndex","cbIdx","invoke","source","macroTaskOption","findMacroTaskOption","args_1","callbackArgs","scheduleTask","onCancelTask","handleId","cancelTask","onInvoke","callback","applyThis","applyArgs","onHandleError","parentZoneDelegate","currentZone","targetZone","window","self","__load_patch","api","ProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","assertPresent","resetDelegate","fakeAsync","proxyZoneSpec","getDelegate","res","lastProxyZoneSpec","setDelegate","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","zoneSpec","symbol"],"mappings":"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","sourcesContent":["var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n* @license Angular v9.1.0-next.4+61.sha-e552591.with-local-changes\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n}((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (global) {\n        var OriginalDate = global.Date;\n        var FakeDate = /** @class */ (function () {\n            function FakeDate() {\n                if (arguments.length === 0) {\n                    var d = new OriginalDate();\n                    d.setTime(FakeDate.now());\n                    return d;\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments);\n                    return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n                }\n            }\n            FakeDate.now = function () {\n                var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncTestZoneSpec) {\n                    return fakeAsyncTestZoneSpec.getCurrentRealTime() + fakeAsyncTestZoneSpec.getCurrentTime();\n                }\n                return OriginalDate.now.apply(this, arguments);\n            };\n            return FakeDate;\n        }());\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        var timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        var Scheduler = /** @class */ (function () {\n            function Scheduler() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTime = 0;\n                // Current real time in millis.\n                this._currentRealTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            Scheduler.prototype.getCurrentTime = function () { return this._currentTime; };\n            Scheduler.prototype.getCurrentRealTime = function () { return this._currentRealTime; };\n            Scheduler.prototype.setCurrentRealTime = function (realTime) { this._currentRealTime = realTime; };\n            Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n                options = Object.assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                var endTime = this._currentTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                var newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                var i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    var currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            };\n            Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n                for (var i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            };\n            Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                var finalTime = this._currentTime + millis;\n                var lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    var current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        var current_1 = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            var idx = this._schedulerQueue.indexOf(current_1);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTime;\n                        this._currentTime = current_1.endTime;\n                        if (doTick) {\n                            doTick(this._currentTime - lastCurrentTime);\n                        }\n                        var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTime] : current_1.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                                var i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    var currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTime;\n                this._currentTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTime - lastCurrentTime);\n                }\n            };\n            Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n                if (limit === void 0) { limit = 20; }\n                if (flushPeriodic === void 0) { flushPeriodic = false; }\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            };\n            Scheduler.prototype.flushPeriodic = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTime - startTime;\n            };\n            Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n                var startTime = this._currentTime;\n                var lastCurrentTime = 0;\n                var count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(function (task) { return !task.isPeriodic && !task.isRequestAnimationFrame; })\n                        .length === 0) {\n                        break;\n                    }\n                    var current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTime;\n                    this._currentTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTime - lastCurrentTime);\n                    }\n                    var retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTime - startTime;\n            };\n            return Scheduler;\n        }());\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        var FakeAsyncTestZoneSpec = /** @class */ (function () {\n            function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n                if (trackPendingRequestAnimationFrame === void 0) { trackPendingRequestAnimationFrame = false; }\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            FakeAsyncTestZoneSpec.assertInZone = function () {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n                var _this = this;\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    fn.apply(global, args);\n                    if (_this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        _this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return _this._lastError === null;\n                };\n            };\n            FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n                var index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n                var _this = this;\n                return function () { FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id); };\n            };\n            FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n                var _this = this;\n                return function () {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        _this._scheduler.scheduleFunction(fn, interval, { args: args, isPeriodic: true, id: id, isRequeuePeriodic: true });\n                    }\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n                var _this = this;\n                return function () { FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id); };\n            };\n            FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n                if (isTimer === void 0) { isTimer = true; }\n                var removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                var cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                var id = this._scheduler.scheduleFunction(cb, delay, { args: args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n                var id = Scheduler.nextId;\n                var completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                var cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args: args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n                var error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            };\n            FakeAsyncTestZoneSpec.prototype.getCurrentTime = function () { return this._scheduler.getCurrentTime(); };\n            FakeAsyncTestZoneSpec.prototype.getCurrentRealTime = function () { return this._scheduler.getCurrentRealTime(); };\n            FakeAsyncTestZoneSpec.prototype.setCurrentRealTime = function (realTime) { this._scheduler.setCurrentRealTime(realTime); };\n            FakeAsyncTestZoneSpec.patchDate = function () {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            };\n            FakeAsyncTestZoneSpec.resetDate = function () {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            };\n            FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n                var _this = this;\n                FakeAsyncTestZoneSpec.assertInZone();\n                var flushErrors = function () {\n                    if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        _this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    var microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            };\n            FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        var args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        var additionalArgs = void 0;\n                        if (args) {\n                            var callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                var macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    var args_1 = task.data && task.data['args'];\n                                    var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            };\n            FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        var macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            var handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (var i = 0; i < this.macroTaskOptions.length; i++) {\n                    var macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            };\n            FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            };\n            return FakeAsyncTestZoneSpec;\n        }());\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('fakeasync', function (global, Zone, api) {\n        var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        var ProxyZoneSpec = Zone && Zone['ProxyZoneSpec'];\n        var _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    var res = void 0;\n                    var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" +\n                            \"periodic timer(s) still in the queue.\");\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis, ignoreNestedTimeout) {\n            if (millis === void 0) { millis = 0; }\n            if (ignoreNestedTimeout === void 0) { ignoreNestedTimeout = false; }\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) { return _getFakeAsyncZoneSpec().flush(maxTurns); }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            var zoneSpec = _getFakeAsyncZoneSpec();\n            var pendingTimers = zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() { _getFakeAsyncZoneSpec().flushMicrotasks(); }\n        Zone[api.symbol('fakeAsyncTest')] = {\n            resetFakeAsyncZone: resetFakeAsyncZone, flushMicrotasks: flushMicrotasks, discardPeriodicTasks: discardPeriodicTasks, tick: tick, flush: flush, fakeAsync: fakeAsync\n        };\n    });\n})));\n"]},"metadata":{},"sourceType":"script"}